"use strict";var _buf="";function _write(){for(var _=[],f=0;f<arguments.length;f++)_[f]=arguments[f];0===_.length&&(console.log(_buf),_buf=""),_.forEach(function(_){String(_).split("").forEach(function(_){"\n"===_?(console.log(_buf),_buf=""):_buf+=_})})}function chooseSymbol(){_write("========= Tic Tac Toe ================","\n");_write("=  Because we know you want to win   =","\n");_write("======================================","\n");_write("=                                    =","\n");_write("= Who would you like to be?          =","\n");_write("=   x  (play first)                  =","\n");_write("=   o  (play second)                 =","\n");_write("=   q  (quit)                        =","\n");_write("=                                    =","\n");_write("======================================","\n");let chosen="\0";while(chosen=="\0"){_write("Which symbol you would like to choose: ");let c="\0";c=read();if(c=="x"||c=="X"){chosen="x"}else{if(c=="o"||c=="O"){chosen="o"}else{if(c=="q"||c=="Q"){_write("Goodbye safety.","\n");return(0)}else{_write("Invalid symbol: ");_write(c,"\n");_write("Please try again.","\n")}}}};_write("You have chosen: ");_write(chosen,"\n");return(chosen)};function printBoard(board){let front=board[0];let row1=front[0];let row2=front[1];let row3=board[1];_write(" 1 2 3","\n");_write("1");let _=printRow(row1);_write(" -+-+-","\n");_write("2");_=printRow(row2);_write(" -+-+-","\n");_write("3");_=printRow(row3);_write("","\n");return(true)};function printRow(row){let front=row[0];let cell1=front[0];let cell2=front[1];let cell3=row[1];let _=printCell(cell1);_write("|");_=printCell(cell2);_write("|");_=printCell(cell3);_write("","\n");return(true)};function printCell(cell){if(cell=="\0"){_write(" ")}else{_write(cell)};return(true)};function askForAMoveHuman(board,move){let success=false;let row=0;let column=0;while(!success){_write("What is your next move?","\n");_write(" row (1-3): ");row=read();_write(" column (1-3): ");column=read();success=validateMove(board,row,column);if(success){_write("","\n");move[0]=row;move[1]=column;return(true)}else{_write("Your move is invalid. Please try again.","\n")}};return(true)};function validateMove(board,moveRow,moveColumn){if(1<=moveRow&&moveRow<=3&&1<=moveColumn&&moveColumn<=3){let sym=symbolAt(board,moveRow,moveColumn);return(sym=="\0")}else{return(false)}};function notifyMoveHuman(board,currentTurn,playerSymbol,moveRow,moveColumn){_write("The AI played at row ");_write(moveRow);_write(" column ");_write(moveColumn,"\n");return(true)};function initAI(aiSymbol){let info=[aiSymbol,null];let stateTree=generateAllPossibleStates(aiSymbol);let value=setValuesForAllStates(stateTree,aiSymbol,"x");let aiData=[info,stateTree];return(aiData)};function generateAllPossibleStates(aiSymbol){let board=allocateNewBoard();let rootState=convertFromBoardToState(board);rootState=generateNextStates(rootState,"x");return(rootState)};function convertFromBoardToState(board){let pointers=generateEmptyPointerBoard();let front=[board,pointers];let state=[front,0];return(state)};function generateEmptyPointerBoard(){let row1=generateEmptyPointerRow();let row2=generateEmptyPointerRow();let row3=generateEmptyPointerRow();let front=[row1,row2];let root=[front,row3];return(root)};function generateEmptyPointerRow(){let front=[null,null];let root=[front,null];return(root)};function generateNextStates(state,currentPlayer){let front=state[0];let board=front[0];let pointers=front[1];let previousPlayer=oppositeSymbol(currentPlayer);let won=hasWon(board,previousPlayer);if(won){return(state)}else{let _=generateNextStatesBoard(board,pointers,currentPlayer);return(state)}};function generateNextStatesBoard(board,pointers,currentPlayer){let front=board[0];let row1=front[0];let row2=front[1];let row3=board[1];let frontP=pointers[0];let row1P=frontP[0];let row2P=frontP[1];let row3P=pointers[1];let _=generateNextStatesRow(board,row1,row1P,currentPlayer,1);_=generateNextStatesRow(board,row2,row2P,currentPlayer,2);_=generateNextStatesRow(board,row3,row3P,currentPlayer,3);return(true)};function generateNextStatesRow(board,row,pointerRow,currentPlayer,rowNumber){let front=row[0];let cell1=front[0];let cell2=front[1];let cell3=row[1];let frontP=pointerRow[0];frontP[0]=generateNextStatesCell(board,cell1,currentPlayer,rowNumber,1);frontP[1]=generateNextStatesCell(board,cell2,currentPlayer,rowNumber,2);pointerRow[1]=generateNextStatesCell(board,cell3,currentPlayer,rowNumber,3);return(true)};function generateNextStatesCell(board,cell,currentPlayer,rowNumber,columnNumber){if(cell=="\0"){let board2=cloneBoard(board);let _=placeMove(board2,currentPlayer,rowNumber,columnNumber);let state=convertFromBoardToState(board2);let nextPlayer=oppositeSymbol(currentPlayer);state=generateNextStates(state,nextPlayer);return(state)}else{return(null)}};function cloneBoard(board){let board2=allocateNewBoard();let _=copyBoard(board,board2);return(board2)};function copyBoard(from,to){let frontFrom=from[0];let row1From=frontFrom[0];let row2From=frontFrom[1];let row3From=from[1];let frontTo=to[0];let row1To=frontTo[0];let row2To=frontTo[1];let row3To=to[1];let _=copyRow(row1From,row1To);_=copyRow(row2From,row2To);_=copyRow(row3From,row3To);return(true)};function copyRow(from,to){let frontFrom=from[0];let frontTo=to[0];frontTo[0]=frontFrom[0];frontTo[1]=frontFrom[1];to[1]=from[1];return(true)};function setValuesForAllStates(state,aiSymbol,currentPlayer){let outValue=0;if(state==null){if(currentPlayer==aiSymbol){outValue=101}else{outValue=(-101)}}else{let front=state[0];let board=front[0];let pointers=front[1];let anotherPlayer=oppositeSymbol(currentPlayer);let won=hasWon(board,anotherPlayer);if(won){if(anotherPlayer==aiSymbol){outValue=100}else{outValue=(-100)}}else{let hasEmptyCell=containEmptyCell(board);if(hasEmptyCell){outValue=calculateValuesFromNextStates(pointers,aiSymbol,anotherPlayer);if(outValue==100){outValue=90}else{;}}else{outValue=0}};state[1]=outValue};return(outValue)};function calculateValuesFromNextStates(pointers,aiSymbol,playerOfNextState){let front=pointers[0];let row1=front[0];let row2=front[1];let row3=pointers[1];let value1=calculateValuesFromNextStatesRow(row1,aiSymbol,playerOfNextState);let value2=calculateValuesFromNextStatesRow(row2,aiSymbol,playerOfNextState);let value3=calculateValuesFromNextStatesRow(row3,aiSymbol,playerOfNextState);let out=combineValue(aiSymbol,playerOfNextState,value1,value2,value3);return(out)};function calculateValuesFromNextStatesRow(rowPointers,aiSymbol,playerOfNextState){let front=rowPointers[0];let state1=front[0];let state2=front[1];let state3=rowPointers[1];let value1=setValuesForAllStates(state1,aiSymbol,playerOfNextState);let value2=setValuesForAllStates(state2,aiSymbol,playerOfNextState);let value3=setValuesForAllStates(state3,aiSymbol,playerOfNextState);let out=combineValue(aiSymbol,playerOfNextState,value1,value2,value3);return(out)};function combineValue(aiSymbol,playerOfNextState,value1,value2,value3){let out=0;if(aiSymbol==playerOfNextState){out=min3(value1,value2,value3)}else{out=max3(value1,value2,value3)};return(out)};function min3(a,b,c){if(a<b){if(a<c){return(a)}else{return(c)}}else{if(b<c){return(b)}else{return(c)}}};function max3(a,b,c){if(a>b){if(a>c){return(a)}else{return(c)}}else{if(b>c){return(b)}else{return(c)}}};function destroyAI(aiData){let info=aiData[0];let stateTree=aiData[1];let _=deleteStateTreeRecursively(stateTree);info=null;aiData=null;return(true)};function askForAMoveAI(board,currentTurn,playerSymbol,aiData,move){let info=aiData[0];let stateTree=aiData[1];let front=stateTree[0];let pointers=front[1];let stateValue=stateTree[1];let _=findTheBestMove(pointers,stateValue,move);_write("AI is cleaning up its memory...","\n");aiData[1]=deleteAllOtherChildren(pointers,move[0],move[1]);_=deleteThisStateOnly(stateTree);return(true)};function findTheBestMove(pointers,stateValue,move){if(stateValue==90){let found=findMoveWithGivenValue(pointers,100,move);if(found){return(true)}else{;}}else{;};let found=findMoveWithGivenValue(pointers,stateValue,move);if(found){return(true)}else{_write("Internal Error: cannot find the next move for the AI","\n");return((-1))}};function findMoveWithGivenValue(pointers,stateValue,move){let front=pointers[0];let row1=front[0];let row2=front[1];let row3=pointers[1];let find=findMoveWithGivenValueRow(row1,stateValue,move);if(find){move[0]=1}else{find=findMoveWithGivenValueRow(row2,stateValue,move);if(find){move[0]=2}else{find=findMoveWithGivenValueRow(row3,stateValue,move);if(find){move[0]=3}else{return(false)}}};return(true)};function findMoveWithGivenValueRow(rowPointers,stateValue,move){let front=rowPointers[0];let cell1=front[0];let cell2=front[1];let cell3=rowPointers[1];let find=hasGivenStateValue(cell1,stateValue);if(find){move[1]=1}else{find=hasGivenStateValue(cell2,stateValue);if(find){move[1]=2}else{find=hasGivenStateValue(cell3,stateValue);if(find){move[1]=3}else{return(false)}}};return(true)};function hasGivenStateValue(state,stateValue){if(state==null){return(false)}else{let actual=state[1];return(actual==stateValue)}};function notifyMoveAI(board,currentTurn,playerSymbol,aiData,moveRow,moveColumn){let stateTree=aiData[1];let front=stateTree[0];let pointers=front[1];_write("AI is cleaning up its memory...","\n");aiData[1]=deleteAllOtherChildren(pointers,moveRow,moveColumn);let _=deleteThisStateOnly(stateTree);return(true)};function deleteAllOtherChildren(pointers,moveRow,moveColumn){let front=pointers[0];let row1=front[0];let row2=front[1];let row3=pointers[1];let toKeepRow=null;let toDeleteRow1=null;let toDeleteRow2=null;if(moveRow==1){toKeepRow=row1;toDeleteRow1=row2;toDeleteRow2=row3}else{toDeleteRow1=row1;if(moveRow==2){toKeepRow=row2;toDeleteRow2=row3}else{toKeepRow=row3;toDeleteRow2=row2}};let out=deleteAllOtherChildrenRow(toKeepRow,moveColumn);let _=deleteChildrenStateRecursivelyRow(toDeleteRow1);_=deleteChildrenStateRecursivelyRow(toDeleteRow2);return(out)};function deleteAllOtherChildrenRow(rowPointers,moveColumn){let front=rowPointers[0];let cell1=front[0];let cell2=front[1];let cell3=rowPointers[1];let toKeepCell=null;let toDeleteCell1=null;let toDeleteCell2=null;if(moveColumn==1){toKeepCell=cell1;toDeleteCell1=cell2;toDeleteCell2=cell3}else{toDeleteCell1=cell1;if(moveColumn==2){toKeepCell=cell2;toDeleteCell2=cell3}else{toKeepCell=cell3;toDeleteCell2=cell2}};let _=deleteStateTreeRecursively(toDeleteCell1);_=deleteStateTreeRecursively(toDeleteCell2);return(toKeepCell)};function deleteStateTreeRecursively(stateTree){if(stateTree==null){return(true)}else{let front=stateTree[0];let board=front[0];let pointers=front[1];let _=deleteChildrenStateRecursively(pointers);_=deleteThisStateOnly(stateTree);return(true)}};function deleteThisStateOnly(stateTree){let front=stateTree[0];let board=front[0];let pointers=front[1];let _=freeBoard(board);_=freePointers(pointers);front=null;stateTree=null;return(true)};function freePointers(pointers){let front=pointers[0];let row1=front[0];let row2=front[1];let row3=pointers[1];let _=freePointersRow(row1);_=freePointersRow(row2);_=freePointersRow(row3);front=null;pointers=null;return(true)};function freePointersRow(rowPointers){let front=rowPointers[0];front=null;rowPointers=null;return(true)};function deleteChildrenStateRecursively(pointers){let front=pointers[0];let row1=front[0];let row2=front[1];let row3=pointers[1];let _=deleteChildrenStateRecursivelyRow(row1);_=deleteChildrenStateRecursivelyRow(row2);_=deleteChildrenStateRecursivelyRow(row3);return(true)};function deleteChildrenStateRecursivelyRow(rowPointers){let front=rowPointers[0];let cell1=front[0];let cell2=front[1];let cell3=rowPointers[1];let _=deleteStateTreeRecursively(cell1);_=deleteStateTreeRecursively(cell2);_=deleteStateTreeRecursively(cell3);return(true)};function askForAMove(board,currentTurn,playerSymbol,aiData,move){if(currentTurn==playerSymbol){let _=askForAMoveHuman(board,move)}else{let _=askForAMoveAI(board,currentTurn,playerSymbol,aiData,move)};return(true)};function placeMove(board,currentTurn,moveRow,moveColumn){let targetRow=null;if(moveRow<=2){let front=board[0];if(moveRow==1){targetRow=front[0]}else{targetRow=front[1]}}else{targetRow=board[1]};if(moveColumn<=2){let front=targetRow[0];if(moveColumn==1){front[0]=currentTurn}else{front[1]=currentTurn}}else{targetRow[1]=currentTurn};return(true)};function notifyMove(board,currentTurn,playerSymbol,aiData,moveRow,moveColumn){if(currentTurn==playerSymbol){let _=notifyMoveAI(board,currentTurn,playerSymbol,aiData,moveRow,moveColumn)}else{let _=notifyMoveHuman(board,currentTurn,playerSymbol,moveRow,moveColumn)};return(true)};function oppositeSymbol(symbol){if(symbol=="x"){return("o")}else{if(symbol=="o"){return("x")}else{_write("Internal Error: symbol given is neither \'x\' or \'o\'","\n");return((-1))}}};function symbolAt(board,row,column){let targetRow=null;if(row<=2){let front=board[0];if(row==1){targetRow=front[0]}else{targetRow=front[1]}}else{targetRow=board[1]};let targetCell="\0";if(column<=2){let front=targetRow[0];if(column==1){targetCell=front[0]}else{targetCell=front[1]}}else{targetCell=targetRow[1]};return(targetCell)};function containEmptyCell(board){let front=board[0];let row1=front[0];let row2=front[1];let row3=board[1];let row1ContainEmpty=containEmptyCellRow(row1);let row2ContainEmpty=containEmptyCellRow(row2);let row3ContainEmpty=containEmptyCellRow(row3);return(row1ContainEmpty||row2ContainEmpty||row3ContainEmpty)};function containEmptyCellRow(row){let front=row[0];let cell1=front[0];let cell2=front[1];let cell3=row[1];return(cell1=="\0"||cell2=="\0"||cell3=="\0")};function hasWon(board,candidate){let c11=symbolAt(board,1,1);let c12=symbolAt(board,1,2);let c13=symbolAt(board,1,3);let c21=symbolAt(board,2,1);let c22=symbolAt(board,2,2);let c23=symbolAt(board,2,3);let c31=symbolAt(board,3,1);let c32=symbolAt(board,3,2);let c33=symbolAt(board,3,3);return(c11==candidate&&c12==candidate&&c13==candidate||c21==candidate&&c22==candidate&&c23==candidate||c31==candidate&&c32==candidate&&c33==candidate||c11==candidate&&c21==candidate&&c31==candidate||c12==candidate&&c22==candidate&&c32==candidate||c13==candidate&&c23==candidate&&c33==candidate||c11==candidate&&c22==candidate&&c33==candidate||c13==candidate&&c22==candidate&&c31==candidate)};function allocateNewBoard(){let row1=allocateNewRow();let row2=allocateNewRow();let row3=allocateNewRow();let front=[row1,row2];let root=[front,row3];return(root)};function allocateNewRow(){let front=["\0","\0"];let root=[front,"\0"];return(root)};function freeBoard(board){let front=board[0];let row1=front[0];let row2=front[1];let row3=board[1];let _=freeRow(row1);_=freeRow(row2);_=freeRow(row3);front=null;board=null;return(true)};function freeRow(row){let front=row[0];front=null;row=null;return(true)};function printAiData(aiData){let info=aiData[0];let stateTree=aiData[1];let _=printStateTreeRecursively(stateTree);return(0)};function printStateTreeRecursively(stateTree){if(stateTree==null){return(true)}else{let front=stateTree[0];let board=front[0];let pointers=front[1];let value=stateTree[1];_write("v");_write("=");_write(value,"\n");let _=printBoard(board);_=printChildrenStateTree(pointers);_write("p","\n");return(true)}};function printChildrenStateTree(pointers){let front=pointers[0];let row1=front[0];let row2=front[1];let row3=pointers[1];let _=printChildrenStateTreeRow(row1);_=printChildrenStateTreeRow(row2);_=printChildrenStateTreeRow(row3);return(true)};function printChildrenStateTreeRow(rowPointers){let front=rowPointers[0];let cell1=front[0];let cell2=front[1];let cell3=rowPointers[1];let _=printStateTreeRecursively(cell1);_=printStateTreeRecursively(cell2);_=printStateTreeRecursively(cell3);return(true)}function _main(){let playerSymbol=chooseSymbol();let aiSymbol=oppositeSymbol(playerSymbol);let currentTurn="x";let board=allocateNewBoard();_write("Initialising AI. Please wait, this may take a few minutes.","\n");let aiData=initAI(aiSymbol);let turnCount=0;let winner="\0";let _=printBoard(board);while(winner=="\0"&&turnCount<9){let move=[0,0];_=askForAMove(board,currentTurn,playerSymbol,aiData,move);_=placeMove(board,currentTurn,move[0],move[1]);_=notifyMove(board,currentTurn,playerSymbol,aiData,move[0],move[1]);_=printBoard(board);let won=hasWon(board,currentTurn);if(won){winner=currentTurn}else{;};currentTurn=oppositeSymbol(currentTurn);turnCount=turnCount+1};_=freeBoard(board);_=destroyAI(aiData);if(winner!="\0"){_write(winner);_write(" has won!","\n")}else{_write("Stalemate!","\n")}};function read(){if(void 0!==typeof _buf&&_write(),"undefined"==typeof process||"node"!==process.release.name)return prompt("stdin:");try{return require("readline-sync").prompt()}catch(e){console.error("Readline Sync not installed!")}};var _exit=_main();if(_buf.length>0){_write()};_exit